## 로그인 처리하기 - 서블릿 HTTP 세션
서블릿은 세션을 위해 `HttpSession`이라는 기능을 제공한다.

### HttpSession 소개
- 서블릿이 세션을 위해 제공하는 기능
- 서블릿을 통해 `HttpSession`을 생성하면 다음과 같은 쿠키를 생성한다. 쿠키 이름이 `JSESSIONID`이고, 값은 추정 불가능한 랜럼 값이다.
    ```text
    Cookie: JSESSIONID=5B78E23B513F50164D6FDD8C97B0AD05
    ```
  
### 서블릿이 제공하는 `HttpSession` 사용하기
#### `SessionConst.java` 생성
```java
public class SessionConst {
    public static final String LOGIN_MEMBER = "loginMember";
}
```
`HttpSession`에 데이터를 보관하고 조회할 때, 같은 이름이 중복되어 사용되므로, 상수를 하나 정의한 것이다.

#### `LoginService.java` 생성
```java
@Service
@RequiredArgsConstructor
public class LoginService {
    
    private final MemberRepository memberRepository;

    /**
     * @return null: 로그인 실패
     */
    public Member login(String loginId, String password) {
        return memberRepository.findByLoginId(loginId)
                .filter(m -> m.getPassword().equals(password))
                .orElse(null);
    }
}
```
#### `LoginController.java` 생성
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class LoginController {

    private final LoginService loginService;

    @GetMapping("/login")
    public String loginForm(@ModelAttribute("loginForm") LoginForm form) {
        return "login/loginForm";
    }

    @PostMapping("/login")
    public String login(@Valid @ModelAttribute LoginForm form, BindingResult bindingResult, HttpServletRequest request) {
        if (bindingResult.hasErrors()) {
            return "login/loginForm";
        }

        Member loginMember = loginService.login(form.getLoginId(), form.getPassword());

        if (loginMember == null) {
            bindingResult.reject("loginFail", "아이디 또는 비밀번호가 맞지 않습니다.");
            return "login/loginForm";
        }

        //로그인 성공 처리
        //세션이 있으면 있는 세션 반환, 없으면 신규 세션을 생성
        HttpSession session = request.getSession();
        
        //세션에 로그인 회원 정보 보관
        session.setAttribute(SessionConst.LOGIN_MEMBER, loginMember);

        return "redirect:/";
    }
}
```

#### 세션 생성과 조회
세션을 생성하려면 `request.getSession(true)`를 사용하면 된다.  
```java
public HttpSession getSession(boolean create);
```

##### 세션의 `create` 옵션
- `request.getSession(true)`
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성해서 반환한다.
- `request.getSession(false)`
  - 세션이 있으면 기존 세션을 반환한다.
  - 세션이 없으면 새로운 세션을 생성하지 않는다. `null`을 반환한다.
- `request.getSession()`
  - 신규 세션을 생성하는 `request.getSession(true)`와 동일하다.
- 

##### 세션에 로그인 회원 정보 보관
```java
session.setAttribute(SessionConst.LOGIN_MEMEBER, loginMember);
```
세션에 데이터를 보관하는 방법은 `request.setAttribute(...)`와 비슷하다. 하나의 세션에 여러 값을 저장할 수 있다.

#### 로그아웃 - LoginController.java에 logout() 생성
```java
@PostMapping("/logout")
public String logoutV3(HttpServletRequest request) {
    // 세션을 삭제한다.
    HttpSession session = request.getSession(false);

    if (session != null) {
        session.invalidate();
    }

    return "redirect:/";
}
```
`session.invalidate()`: 세션을 제거한다.

#### HomeController.java 생성
```java
@Slf4j
@Controller
@RequiredArgsConstructor
public class HomeController {

  @GetMapping("/")
  public String home(HttpServletRequest request, Model model) {
    HttpSession session = request.getSession(false);

    // 세션이 없으면 home
    if (session == null) {
      return "home";
    }

    Member loginMember = (Member) session.getAttribute(SessionConst.LOGIN_MEMBER);
    // 세션에 회원 데이터가 없으면 home
    if (loginMember == null) {
      return "home";
    }

    // 세션이 유지되면 로그인으로 이동
    model.addAttribute("member", loginMember);
    return "loginHome";
  }
}
```
- `request.getSession(false)`: `request.getSession()`를 사용하면 기본 값이 `create: true`이므로, 
로그인하지 않을 사용자도 의미없는 세션이 만들어진다. 따라서 세션을 찾아서 사용하는 시점에는 `create:false`옵션을 사용해서 세션을 생성하지 않아야 한다.
- `session.getAttribute(SessionConst.LOGIN_MEMBER)`: 로그인 시점에 세션에 보관한 회원 객체를 찾는다.

#### 실행
`JSESSIONID` 쿠키가 생성된다.

### @SessionAttribute
스프링은 세션을 더 편리하게 사용할 수 있도록 `@SessionAttribute`를 지원한다.  
이미 로그인된 사용자를 찾을 때는 다음과 같이 사용하면 된다. 참고로 이 기능은 세션을 생성하지 않는다.
`@SessionAttribute(name = "loginMember", required = false) Member loginMember`

### HomeController.java - home() 수정
```java
@GetMapping("/")
public String home(@SessionAttribute(name = SessionConst.LOGIN_MEMBER, required = false) Member loginMember, Model model) {
    // 세션에 회원 데이터가 없으면 home
    if (loginMember == null) {
        return "home";
    }

    // 세션이 유지되면 로그인으로 이동
    model.addAttribute("member", loginMember);
    return "loginHome";
}
```
세션을 찾고, 세션에 들어있는 데이터를 찾는 번거로운 과정을 스프링이 한 번에 편리하게 처리해준다.

### TrackingModes
로그인을 처음 시도하면 URL이 다음과 같이 `jsessionid`를 포함하고 있는 것을 확인할 수 있다.
```text
http://localhost:8080/;jsessionid=B507F38494A29FDA213CA0A265B20661
```
이것은 웹 브라우저가 쿠키를 지원하지 않을 때 쿠키 대신 URL을 통해서 세션을 유지하는 방법이다.
이 방법을 사용하려면 URL에 이 값을 계속 포함해서 전달해야 한다. 타임리프 같은 엔진을 통해서 링크를 걸면 `jsessionid`를 URL에 자동으로 포함해준다.
서버 입장에서 웹 브라우저가 쿠키를 지원하는지 하지 않는 지 최초에는 판단하지 못하므로, 쿠키 값도 전달하고, URL에 `jsessionid`도 함께 전달한다.  
URL 전달 방식을 끄고 항상 쿠키를 통해서만 세션을 유지하고 싶다면 다음 옵션을 넣어주면 된다. 이렇게하면 URL에 `jsessionid`가 노출되지 않는다.
```text
[application.properties]

server.servlet.session.tracking-modes=cookie
```

## 세션 정보와 타임아웃 설정
### 세션이 제공하는 정보들 확인하기 (`SessionInfoController.java` 생성)
```java
@Slf4j
@RestController
public class SessionInfoController {
    
    @GetMapping("/session-info")
    public String sessionInfo(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session == null) {
            return "세션이 없습니다.";
        }

        //세션 데이터 출력
        session.getAttributeNames().asIterator().forEachRemaining(name -> log.info("session name={}, value={}", name, session.getAttribute(name)));

        log.info("sessionId={}", session.getId());
        log.info("getMaxInactiveInterval={}", session.getMaxInactiveInterval());
        log.info("creationTime={}", new Date(session.getCreationTime()));
        log.info("lastAccessedTime={}", new Date(session.getLastAccessedTime()));
        log.info("isNew={}", session.isNew());

        return "세션 출력";
    }
}
```
- `sessionId`: 세션Id, `JSESSIONID`의 값
- `maxInactiveInterval`: 세션의 유효 시간 (예: 1800초, (30분))
- `creationTime`: 세션 생성일시
- `lastAccessedTime`: 세션과 연결된 사용자가 최근에 서버에 접근한 시간, 클라이언트에서 서버로 `sessionId`(`JSESSIONID`)를 요청한 경우에 갱신된다.
- `isNew`: 새로 생셩된 세션인지, 아니면 이미 과거에 만들어졌고, 클라이언트에서 서버로 `sessionId`(`JSESSIONID`)를 요청해서 조회된 세션인지 여부

### 세션 타임아웃 설정
세션은 사용자가 로그아웃을 직접 호출해서 `session.invalidate()`가 호출되는 경우에 삭제된다.
그런데 대부분의 사용자는 로그아웃을 선택하지 않고, 웹 브라우저를 종료한다.
문제는 HTTP가 비연결성(ConnectionLess)이므로 서버 입장에서는 해당 사용자가 웹 브라우저를 종료한 것인지 아닌지를 인식할 수 없다.
따라서 서버에서 세션 데이터를 언제 삭제해야 하는지 판단하기 어렵다.
이 경우 남아있는 세션을 무한정 보관하면 다음과 같은 문제가 발생할 수 있다.
- 세션과 관련된 쿠키(`JSESSIONID`)를 탈취 당했을 경우 오랜 시간이 지나도 해당 쿠키로 악의적인 요청을 할 수 있다.
- 세션은 기본적으로 메모리에 생성된다. 메모리의 크기가 무한하지 않기 때문에 꼭 필요한 경우만 생성해서 사용해야 한다.

#### 세션의 종료 시점
세션의 종료 시점은 사용자가 서버에 최근에 요청한 시간을 기준으로 30분 정도를 유지해주는 것이 좋다. 이렇게 하면 사용자가 서비스를 사용하고 있으면, 세션의 생존 시간이 30분으로 계속 늘어나게 된다.
`HttpSession`은 이 방식을 사용한다.

#### 세션 타임아웃 설정
```text
[application.properties]

server.servlet.session.timeout=60
```
해당 내용은 60초로 세팅하는 것이고, 기본은 1800초이다. (글로벌 설정은 분 단위로 설정해야 한다.)
> 🍀 특정 세션 단위로 시간 설정
> `session.setMaxInactiveInterval(1800);` // 1800초

#### 세션 타임아웃 발생
세션의 타임아웃 시간은 해당 세션과 관련된 `JSESSIONID`를 전달하는 HTTP 요청이 있으면 현재 시간으로 다시 초기화된다.
이렇게 초기화되면 세션 타임아웃으로 설정한 시간동안 세션을 추가로 사용할 수 있다.  
`session.getLastAccessedTime()`: 최근 세션 접근 시간  
`LastAccessedTime`이후로 timeout시간이 지나면, WAS가 내부에서 해당 세션을 제거한다.