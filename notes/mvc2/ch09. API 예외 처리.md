## API 예외 처리
HTML 페이지의 경우 지금까지 설명했던 것 처럼 4xx, 5xx와 같은 오류 페이지만 있으면 대부분 이런 문제를 해결할 수 있다.
그런데 API의 경우 생각할 내용이 더 많다.
오류 페이지는 단순히 고객에게 오류 화면을 보여주고 끝이지만, API는 각 오류 상황에 맞는 오류 응답 스펙을 정하고, JSON으로 데이터를 내려주어야 한다.

## 서블릿의 API 오류 처리
#### [WebServerCustomizer.java](..%2F..%2Fsrc%2Fmain%2Fjava%2Fhello%2Fitemservice%2FWebServerCustomizer.java)
- `@Component` 주석 제거
  - 이제 WAS에 예외가 전달되거나, `response.sendError()`가 호출되면 위에 등록한 예외 페이지 경로가 호출된다.


#### [ApiExceptionController.java](..%2F..%2Fsrc%2Fmain%2Fjava%2Fhello%2Fitemservice%2Fweb%2Fcontroller%2FApiExceptionController.java)
```java
@Slf4j
@RestController
public class ApiExceptionController {

    @GetMapping("/api/members/{id}")
    public MemberDTO getMember(@PathVariable("id") String id) {
        if (id.equals("ex")) {
            throw new RuntimeException("잘못된 사용자");
        }

        return new MemberDTO(id, "hello " + id);
    }
    
    @Data
    @AllArgsConstructor
    static class MemberDTO {
        private String memberId;
        private String name;
    }
}
```

단순 회원 조회 기능으로, 예외 테스트를 위해 URL에 전달된 `id`값이 `ex`이면 예외가 발생하도록 코드를 심어주었다.

##### Postman 테스트
HTTP Header의 `Accept`를 `application/json`으로 설정한다.

###### 정상 호출
`http://localhost:8080/api/members/spring`  

[실행 결과]
```json
{
    "memberId": "spring",
    "name": "hello spring"
}
```

###### 예외 발생 호출
```html
<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8">
</head>

<body>

    <div class="container" style="max-width: 600px">
        <div class="py-5 text-center">
            <h2>500 오류 화면</h2>
        </div>

        <div>
            <p>오류 화면 입니다.</p>
        </div>

        <hr class="my-4">

    </div> <!-- /container -->

</body>

</html>
```

API를 요청했는데, 정상의 경우 API 응답이 JSON 형식 데이터가 반환된다.
그런데 오류가 발생하면 오류 페이지 HTML이 반환된다. 
클라이언트는 정상 요청이든, 오류 요청이든 JSON이 반환되기를 기대한다.
웹 브라우저가 아닌 이상 HTML을 직접 받아서 할 수 있는 것은 없다.

문제를 해결하려면 오류 페이지 컨트롤러도 JSON 응답을 할 수 있도록 수정해야 한다.


### [ErrorPageController.java](..%2F..%2Fsrc%2Fmain%2Fjava%2Fhello%2Fitemservice%2Fweb%2Fcontroller%2FErrorPageController.java) errorPage500Api() 추가
```java
@RequestMapping(value = "/error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<Map<String, Object>> errorPage500Api(HttpServletRequest request, HttpServletResponse response) {
    log.info("API errorPage 500");
    
    Map<String, Object> result = new HashMap<>();
    Exception ex = (Exception) request.getAttribute(ERROR_EXCEPTION);
    result.put("status", request.getAttribute(ERROR_STATUS_CODE));
    result.put("message", ex.getMessage());

    Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);

    return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));
}
```

`produces = Mediatype.APPLICATION_JSON_VALUE`는 클라이언트가 요청하는 HTTP header의 `Accept`의 값이
`application/json`일 때 해당 메서드가 호출된다는 뜻이다.
결국 클라이언트가 받고 싶은 미디어타입이 `json`이면 이 컨트롤러의 메소드가 호출된다.

응답 데이터를 위해 `Map`을 만들고 `status`, `message` 키에 값을 할당했다.
Jackson 라이브러리는 `Map`을 JSON 구조로 변환할 수 있다.

`ResponseEntity`를 사용해서 응답하기 때문에 메시지 컨버터가 동작하면서 클라이언트에 JSON이 반환된다.

#### Postman 테스트
`http://localhost:8080/api/members/ex`  

[실행 결과]
```json
{
    "message": "잘못된 사용자",
    "status": 500
}
```

HTML Header에 `Accept`가 `application/json`이 아니면, 기존 오류 응답인 HTML 응답이 호출되는 것을 확인할 수 있다.

## 스프링 부트 기본 오류 처리
API 예외 처리도 스프링 부트가 제공하는 기본 오류 방식을 사용할 수 있다.
#### BasicErrorController 코드
```java
@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { }

@RequestMapping
public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) { }
```

- `errorHtml()`-`produces = MediaType.TEXT_HTML_VALUE`: 클라이언트 요청의 Accept 헤더 값이 `text/html`인 경우에는
`errorHtml()`을 호출해서 view 를 제공한다.
- `error()`: 그 외 경우에 호출되고 `ResponseEntity`로 HTTP Body 에 JSON 데이터를 반환한다.

### 스프링 부트의 예외 처리
스프링 부트의 기본 설정은 오류 발생 시 `/error`를 오류 페이지로 요청한다.

`BasicErrorController`는 이 경로를 기본으로 받는다. (`server.error.path`로 수정 가능, 기본 경로 `/error`)

#### Postman 으로 실행
1. [WebServerCustomizer.java](..%2F..%2Fsrc%2Fmain%2Fjava%2Fhello%2Fitemservice%2FWebServerCustomizer.java)의 `@Component` 주석 처리하기.
2. [application.properties](..%2F..%2Fsrc%2Fmain%2Fresources%2Fapplication.properties) 설정 변경
    ```properties
    server.error.include-binding-errors=always
    server.error.include-exception=true
    server.error.include-message=always
    server.error.include-stacktrace=always
    ```
3. `GET: http://localhost:8080/api/members/ex` 실행
    ```
    {
        "timestamp": "2021-04-28T00:00:00.000+00:00", "status": 500,
        "error": "Internal Server Error",
        "exception": "java.lang.RuntimeException",
        "trace": "java.lang.RuntimeException: 잘못된 사용자\n\tat
        hello.exception.web.api.ApiExceptionController.getMember(ApiExceptionController
        .java:19...,
        "message":"잘못된 사용자",
        "path": "/api/members/ex"
    }
    ```

### Html 페이지 vs API 오류
`BasicErrorController`를 확장하면 JSON 메시지도 변경할 수 있다. 그런데 API 오류는 조금 뒤에 설명할
`@ExceptionHandler`가 제공하는 기능을 사용하는 것이 더 나은 방법이므로 지금은 `BasicErrorController`를 확장해서
JSON 오류 메시지를 변경할 수 있다 정도로만 이해하자.

스프링 부트가 제공하는 `BasicErrorController`는 HTML 페이지를 제공하는 경우에는 매우 편리하다.
4xx, 5xx 등등 모두 잘 처리해준다. 그런데 API 오류 처리는 다른 차원의 이야기이다.
API마다, 각각의 컨트롤러나 예외마다 서로 다른 응답 결과를 출력해야 할 수도 있다.
예를 들어서 회원과 관련된 API에서 예외가 발생할 때 응답과, 상품과 관련된 API에서 발생하는 예외에 따라 그 결과가 달라질 수 있다.

결과적으로 매우 세밀하고 복잡하다. 따라서 이 방법은 HTML 화면을 처리할 때 사용하고, API 오류 처리는 뒤에 설명할 `@ExceptionHandler`를 사용하자.
