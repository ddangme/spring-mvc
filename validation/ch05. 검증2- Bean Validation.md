## Bean Validation 소개
- 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준이다. 즉, 검증 애노테이션과 여러 인터페이스의 모음이다. (마치 JPA가 표준 기술이고 그 구현체로 하이버네이트가 있는 것과 같다.)
- 구현한 기술 중에 일반적으로 사용하는 구현체는 하이버네이크 Validator이다. (ORM과는 관련이 없다.)
- 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고 표준화 한 것

> **🍀 하이버네이트 Validator 관련 링크**  
> - [공식 사이트](http://hibernate.org/validator/)
> - [공식 메뉴얼](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/)
> - [검증 애노테이션 모음](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec)

## 순수한 Bean Validation 사용법
### Bean Validation 의존관계 추가
```properties
[build.gradle]

implementation 'org.springframework.boot:spring-boot-starter-validation'
```
`spring-boot-starter-validation` 의존관계를 추가하면 라이브러리가 추가된다.
#### Jakarta Bean Validation
- `jakarta.validation-api`: Bean Validation 인터페이스
- `hibernate-validator`: 구현체

### 테스트 코드 작성
1. `Item.class` 수정하기
```java
@Data
public class Item {

    private Long id;
    
    @NotBlank
    private String itemName;
    
    @NotNull
    @Range(min = 1_000, max = 1_000_000)
    private Integer price;
    
    @NotNull
    @Max(9_999)
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```
**검증 애노테이션**
- `@NotBlank`: 빈값 + 공백만 있는 경우를 허용하지 않는다.
- `@NotNull`: `null`을 허용하지 않는다.
- `@Range(min = 1, max = 100)`: 범위 안의 값이어야 한다.
- `@Max(999)`: 해당 숫자 이상의 값을 허용하지 않는다.

> 🍀참고  
> `javax.validation.constraints.NotNull`  
> `org.hibernate.validator.constraints.Range`  
>   
> `javax.validation`으로 시작하면 특정 구현에 관계없이 제공되는 표준 인터페이스이고,   
> `org.hibernate.validator`로 시작하면 하이버네이트 validator 구현체를 사용할 때만 제공되는 검증기능이다.
2. BeanValidationTest - Bean Validation 테스트 코드 작성
```java
public class BeanValidationTest {

    @Test
    void beanValidation() {
        // 검증기 생성
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();

        Item item = new Item();
        item.setItemName("   ");
        item.setPrice(0);
        item.setQuantity(10_000);

        // 검증 실행
        Set<ConstraintViolation<Item>> violations = validator.validate(item);

        for (ConstraintViolation<Item> violation : violations) {
            System.out.println("violation = " + violation);
            System.out.println("violation.message = " + violation.getMessage());
        }
    }
}
```
- 검증 실행
  - 검증 대상(`item`)을 직접 검증기에 넣고 그 결과를 받는다. `Set`에는 `ConstraintViolation`이라는 검증 오류가 담긴다.
따라서 결과가 비어있으면 검증 오류가 없는 것이다.
- 실행 결과
    ```text
    violation={interpolatedMessage='공백일 수 없습니다', propertyPath=itemName, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.NotBlank.message}'}
    violation.message=공백일 수 없습니다
    
    violation={interpolatedMessage='9999 이하여야 합니다', propertyPath=quantity, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.Max.message}'}
    violation.message=9999 이하여야 합니다
    
    violation={interpolatedMessage='1000에서 1000000 사이여야 합니다', propertyPath=price, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{org.hibernate.validator.constraints.Range.message}'}
    violation.message=1000에서 1000000 사이여야 합니다
    ```
    - `ConstraintViolation` 출력 결과를 보면, 검증 오류가 발생한 객체, 필드, 메시지 정보 등 다양한 정보를 확인할 수 있다.

> 🍀 참고  
> 특정 필드의 범위를 넘어서는 검증(가격 * 수량의 합은 10,000원 이상) 기능이 빠졌는데, 이 부분은 뒤에서 설명한다.

## 스프링 Bean Validation 적용
### 스프링 MVC는 어떻게 Bean Validator를 사용할까?
- 스프링 부트가 `spring-boot-starter-validation` 라이브러리를 넣으면 자동으로 Bean Validator를 인지하고 스프링에 통합한다.
- 스프링 부트는 자동으로 글로벌 Validator로 등록한다.
  - `LocalValidatorFactoryBean`을 글로벌 Validator로 등록한다. 이 Validator는 `@NotNull`같은 애노테이션을 보고 검증을 수행한다.
이렇게 글로벌 Validator가 적용되어 있기 때문에, `@Valid`, `@Validated`만 적용하면 된다.
  - 검증 오류가 발생하면, `FieldError`, `ObjectError`를 생성해서 `BindingResult`에 담아준다.

> 🚨 주의  
> 직접 글로벌 Validator를 직접 등록하면 스프링 부트는 Bean Validator를 글로벌 `Validator`로 등록하지 않는다. 따라서 애노테이션 기반의 빈 검증기가 동작하지 않는다.

> 🍀 참고  
> 검증 시 `@Validated`, `@Valid` 둘다 사용가능하다.  
> `javax.validation.@Valid`를 사용하려면 `build.gradle`에 의존관계 추가가 필요하다.  
> `@Validated`는 스프링 전용 검증 애노테이션이고, `@Valid`는 자바 표준 검증 애노테이션이다. 둘중 아무거나 사용해도 동일하게 작동하지만, `@Validated`는 내부에 `groups`라는 기능을 포함하고 있다. (groups는 뒤에서 설명한다.)

### 검증 순서
1. `@ModelAttribute` 각각의 필드에 타입 변환 시도
   1. 성공하면 다음으로
   2. 실패하면 `typeMismatch`로 `FieldError` 추가 
2. Validator 적용

### 바인딩에 성공한 필드만 Bean Validation 적용
BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않는다.  
`@ModelAttribute` -> 각각의 필드 타입 변환시도 -> **변환에 성공한 필드만 BeanValidation 적용**  

## Bean Validation 에러 코드
Bean Validation이 기본으로 제공하는 오류 메시지를 자세히 변경하고 싶다면?  
Bean Validation을 적용하고 `bindingResult`에 등록된 검증 오류 코드를 보자.  
오류 코드가 애노테이션 이름으로 등록된다. 마치 `typeMismatch`와 유사하다.  
`NotBlank`라는 오류 코드를 기반으로 `MessageCodesResolver`를 통해 다양한 메시지 코드가 순서대로 생성된다.

### @NotBlank
- NotBlank.item.itemName
- NotBlank.itemName
- NotBlank.java.lang.String
- NotBlank

### @Range
- Range.item.price
- Range.price
- Range.java.lang.Integer
- Range

### 메시지 등록
```properties
[errors.properties]

#Bean Validation 추가
NotBlank={0} 공백X
Range={0}, {2} ~ {1} 허용
Max={0}, 최대 {1}
```
- `{0}`은 필드명이고, `{1}`, `{2}`...은 각 애노테이션 마다 다르다.

### Bean Validation 메시지 찾는 순서
1. 생성된 메시지 코드 순서대로 `messageSource`에서 찾기
2. 애노테이션의 `message` 속성 사용 -> `@NotBlank(message = "공백! {0}")
3. 라이브러리가 제공하는 기본 값 사용 -> 공백일 수 없습니다.

### 애노테이션의 message 사용 예
```java
@NotBlank(message = "공백은 입력할 수 없습니다.")
private String itemName;
```

## Bean Validation - 오브젝트 오류
Bean Validation에서 특정 필드(`FieldError`)가 아닌 해당 오브젝트 관련 오류(`ObjectError`)는 어떻게 처리할 수 있을까?  
다음과 같이 `@ScriptAssert()`를 사용하면 된다.
```java
@Data
@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >= 10000")
public class Item {
    //...
}
```
실행해보면 정상 수행되는 것을 확인할 수 있다. 메시지 코드는 다음과 같이 생성된다.
- `ScriptAssert.item`
- `ScriptAssert`  

그런데 실제 사용해보면 제약이 많고 복잡하다. 그리고 실무에서는 검증 기능이 해당 객체의 범위를 넘어서는 경우들도 있기 때문에, 그런 경우 대응이 어렵다.  
따라서 오브젝트 오류(글로벌 오류)의 경우 `@ScriptAssert`를 억지로 사용하는 것 보다 다음과 같이 오브젝트 오류 관련 부분만 직접 자바 코드로 작성하는 것을 권장한다.
```java
public String addItem(@Validated @ModelAttribute Item item, BindingResult bindingResult, RedirectAttributes redirectAttributes) {
    // 특정 필드 예외가 아닌 전체 예외
    if (item.getPrice() != null && item.getQuantity() != null) {
        int resultPrice = item.getPrice() * item.getQuantity();

        if (resultPrice < 10_000) {
            bindingResult.reject("totalPriceMin", new Object[]{10_000, resultPrice}, null);
        }
    }
    
    //검증에 실패하면 다시 입력 폼으로
    if (bindingResult.hasErrors()) {
        log.info("errors={} ", bindingResult);
        return "validation/addForm";
    }

    //성공 로직
    Item savedItem = itemRepository.save(item);
    redirectAttributes.addAttribute("itemId", savedItem.getId());
    redirectAttributes.addAttribute("status", true);
    return "redirect:/validation/items/{itemId}";
}
```

## Bean Validation - 수정 페이지에 적용
### ValidationItemController - edit() 변경
```java
public String edit(@PathVariable Long itemId, @Validated @ModelAttribute Item item, BindingResult bindingResult) {
    // 특정 필드 예외가 아닌 전체 예외
    if (item.getPrice() != null && item.getQuantity() != null) {
        int resultPrice = item.getPrice() * item.getQuantity();

        if (resultPrice < 10_000) {
            bindingResult.reject("totalPriceMin", new Object[]{10_000, resultPrice}, null);
        }
    }

    if (bindingResult.hasErrors()) {
        log.info("errors={}", bindingResult);
        return "validation/editForm";

    }
    itemRepository.update(itemId, item);
    return "redirect:/validation/items/{itemId}";
}
```

### validation/v3/editForm.html 변경
```html

```