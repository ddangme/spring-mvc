## Bean Validation 소개
- 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준이다. 즉, 검증 애노테이션과 여러 인터페이스의 모음이다. (마치 JPA가 표준 기술이고 그 구현체로 하이버네이트가 있는 것과 같다.)
- 구현한 기술 중에 일반적으로 사용하는 구현체는 하이버네이크 Validator이다. (ORM과는 관련이 없다.)
- 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고 표준화 한 것

> **🍀 하이버네이트 Validator 관련 링크**  
> - [공식 사이트](http://hibernate.org/validator/)
> - [공식 메뉴얼](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/)
> - [검증 애노테이션 모음](https://docs.jboss.org/hibernate/validator/6.2/reference/en-US/html_single/#validator-defineconstraints-spec)

## 순수한 Bean Validation 사용법
### Bean Validation 의존관계 추가
```properties
[build.gradle]

implementation 'org.springframework.boot:spring-boot-starter-validation'
```
`spring-boot-starter-validation` 의존관계를 추가하면 라이브러리가 추가된다.
#### Jakarta Bean Validation
- `jakarta.validation-api`: Bean Validation 인터페이스
- `hibernate-validator`: 구현체

### 테스트 코드 작성
1. `Item.class` 수정하기
```java
@Data
public class Item {

    private Long id;
    
    @NotBlank
    private String itemName;
    
    @NotBlank
    @Range(min = 1_000, max = 1_000_000)
    private Integer price;
    
    @NotNull
    @Max(9_999)
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
```
**검증 애노테이션**
- `@NotBlank`: 빈값 + 공백만 있는 경우를 허용하지 않는다.
- `@NotNull`: `null`을 허용하지 않는다.
- `@Range(min = 1, max = 100)`: 범위 안의 값이어야 한다.
- `@Max(999)`: 해당 숫자 이상의 값을 허용하지 않는다.

> 🍀참고  
> `javax.validation.constraints.NotNull`  
> `org.hibernate.validator.constraints.Range`  
>   
> `javax.validation`으로 시작하면 특정 구현에 관계없이 제공되는 표준 인터페이스이고,   
> `org.hibernate.validator`로 시작하면 하이버네이트 validator 구현체를 사용할 때만 제공되는 검증기능이다.
2. BeanValidationTest - Bean Validation 테스트 코드 작성
```java
public class BeanValidationTest {

    @Test
    void beanValidation() {
        // 검증기 생성
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();

        Item item = new Item();
        item.setItemName("   ");
        item.setPrice(0);
        item.setQuantity(10_000);

        // 검증 실행
        Set<ConstraintViolation<Item>> violations = validator.validate(item);

        for (ConstraintViolation<Item> violation : violations) {
            System.out.println("violation = " + violation);
            System.out.println("violation.message = " + violation.getMessage());
        }
    }
}
```
- 검증 실행
  - 검증 대상(`item`)을 직접 검증기에 넣고 그 결과를 받는다. `Set`에는 `ConstraintViolation`이라는 검증 오류가 담긴다.
따라서 결과가 비어있으면 검증 오류가 없는 것이다.
- 실행 결과
    ```text
    violation={interpolatedMessage='공백일 수 없습니다', propertyPath=itemName, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.NotBlank.message}'}
    violation.message=공백일 수 없습니다
    
    violation={interpolatedMessage='9999 이하여야 합니다', propertyPath=quantity, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{javax.validation.constraints.Max.message}'}
    violation.message=9999 이하여야 합니다
    
    violation={interpolatedMessage='1000에서 1000000 사이여야 합니다', propertyPath=price, rootBeanClass=class hello.itemservice.domain.item.Item, messageTemplate='{org.hibernate.validator.constraints.Range.message}'}
    violation.message=1000에서 1000000 사이여야 합니다
    ```
    - `ConstraintViolation` 출력 결과를 보면, 검증 오류가 발생한 객체, 필드, 메시지 정보 등 다양한 정보를 확인할 수 있다.

> 🍀 참고  
> 특정 필드의 범위를 넘어서는 검증(가격 * 수량의 합은 10,000원 이상) 기능이 빠졌는데, 이 부분은 뒤에서 설명한다.

## 스프링 Bean Validation 적용
### 스프링 MVC는 어떻게 Bean Validator를 사용할까?
- 스프링 부트가 `spring-boot-starter-validation` 라이브러리를 넣으면 자동으로 Bean Validator를 인지하고 스프링에 통합한다.
- 스프링 부트는 자동으로 글로벌 Validator로 등록한다.
  - `LocalValidatorFactoryBean`을 글로벌 Validator로 등록한다. 이 Validator는 `@NotNull`같은 애노테이션을 보고 검증을 수행한다.
이렇게 글로벌 Validator가 적용되어 있기 때문에, `@Valid`, `@Validated`만 적용하면 된다.
  - 검증 오류가 발생하면, `FieldError`, `ObjectError`를 생성해서 `BindingResult`에 담아준다.

> 🚨 주의  
> 직접 글로벌 Validator를 직접 등록하면 스프링 부트는 Bean Validator를 글로벌 `Validator`로 등록하지 않는다. 따라서 애노테이션 기반의 빈 검증기가 동작하지 않는다.

> 🍀 참고  
> 검증 시 `@Validated`, `@Valid` 둘다 사용가능하다.  
> `javax.validation.@Valid`를 사용하려면 `build.gradle`에 의존관계 추가가 필요하다.  
> `@Validated`는 스프링 전용 검증 애노테이션이고, `@Valid`는 자바 표준 검증 애노테이션이다. 둘중 아무거나 사용해도 동일하게 작동하지만, `@Validated`는 내부에 `groups`라는 기능을 포함하고 있다. (groups는 뒤에서 설명한다.)

### 검증 순서
1. `@ModelAttribute` 각각의 필드에 타입 변환 시도
   1. 성공하면 다음으로
   2. 실패하면 `typeMismatch`로 `FieldError` 추가 
2. Validator 적용

### 바인딩에 성공한 필드만 Bean Validation 적용
BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않는다.  
`@ModelAttribute` -> 각각의 필드 타입 변환시도 -> **변환에 성공한 필드만 BeanValidation 적용**  
